> 原文链接: https://www.anquanke.com//post/id/260896 


# 比特翻转攻击


                                阅读量   
                                **117075**
                            
                        |
                        
                                                                                    



[![](https://p1.ssl.qhimg.com/t01a6240a40f2963de7.jpg)](https://p1.ssl.qhimg.com/t01a6240a40f2963de7.jpg)



## 前言

在之前的文章中我们已经介绍过针对深度学习系统的攻击手段，比如对抗样本攻击、后门攻击、模型窃取等，对抗样本攻击、后门攻击的目的都是为了让模型将某一特定测试样本分类到攻击者指定的类别。但是，从攻击者的角度来看，如果不考虑“隐蔽性”问题，是否存在一种方法可以全面降低模型的性能呢，而不仅仅是降低模型在某一特定样本上的性能。答案是肯定的，本文就介绍一种方案，其通过修改模型的权重全面降低模型的性能，或者说彻底摧毁模型，而修改权重的方案则是对位于内存中的模型权重进行比特翻转。攻击示意图如下

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://pic.imgdb.cn/item/61a2d9082ab3f51d9169e688.jpg)



## 模型权重及Row Hammer攻击

我们知道，深度学习系统训练的目的就是为了找到合适的权重，可以说权重是模型最宝贵的资产，所以我们自然需要考虑模型权重的安全性问题。不过之前很少有人考虑过这个方面，这可能是因为：1.神经网络通过被认为是一个抗权重变化的鲁棒系统，大家认为权重发生一点变化是无关紧要的；2.深度神经网络通过部署在高性能计算系统比如CPU\GPU以及其他加速器上，这些系统通过有多种保证数据完整性的方法，所以模型的权重不容易被修改。

但是，目前已经有研究表明，通过row hammer、laser beam等常见的故障注入技术可以对模型权重进行修改，从而篡改深度神经网络。

已经有人尝试利用row hammer技术攻击存储在DRAM中的DNN网络权重，不过该方案存在关键的限制，它们主要集中在非常脆弱的全精度DNN模型，这种模型的参数都是浮点型的，但是随机翻转浮点数的指数部分很容易导致DNN出错，其原因在于翻转浮点数的指数部分会将权值增加到一个非常大的值，从而导致爆炸输出。因此，该攻击技术可以用，但是攻击对象最好是有权值约束的，即将权值量化为定点值的模型，所以在下文我们还会介绍怎么对权重进行量化。

我们的攻击是通过比特翻转进行的，这种技术已经比较成熟了。Kim等人就演示了通过频繁的数据访问就能在DRAM中引起内存位翻转，被称为Row-Hammer Attack (RHA)。攻击者可以使用RHA修改存储在DRAM存储单元中的数据，每次只翻转一位。也有研究工作通过为DRAM中的位翻转创建一个配置文件，row hammer可以有效地在软件堆栈中的任何地址上翻转单个位。根据最新的研究，常见的纠错技术如纠错码(ECC)和Intel SGX都无法抵御row hammer。现有的内存位翻转攻击(即row hammer)模型给DNN计算系统的安全性带来了巨大的挑战，因为为了最大限度地提高计算吞吐量，模型参数通常存储在主存即DRAM中，相当于直接暴露在敌方攻击者面前。

此外，由于DNN应用被广泛部署在许多资源有限(如智能物联网设备、移动系统、边缘设备等)，它们缺乏必要的数据完整性检查机制，所以更容易受到攻击。



## 攻击方案

通过翻转少量的权重位实现对深度学习系统的攻击。

使用一种称为PBS（Progressive Bit Search）的算法，识别存储在DRAM上的容易受攻击的DNN权重参数，通过最小的比特位翻转次数可以最大限度地降低模型的精度。

首先我们需要形式化定义问题：

给定一个量化的包含L个卷积或全连接层的DNN,我们将原始的浮点数形式的权值通过Nq-bits统一量化器量化到2^Nq-1层级。被量化的权值W在数学上可以用Nq位有符号整数表示，而在内存中，W是以二进制格式存储的，我们用B来表示。我们现在的目的是要找到用于翻转的最优权值组合，该问题可以表示为下面的优化问题

[![](https://p3.ssl.qhimg.com/t01b07f4d9bc1b4b5fb.png)](https://p3.ssl.qhimg.com/t01b07f4d9bc1b4b5fb.png)

上式中，B^是扰动后的权重，x和t分别是向量化后的输入和目标输出

我们以x为输入，用`{`B^l`}`l=1参数化的网络推理计算过程可以表示为：

[![](https://p0.ssl.qhimg.com/t01dde734ad37622a50.png)](https://p0.ssl.qhimg.com/t01dde734ad37622a50.png)

L则用于计算DNN输出与目标输出之间的损失

D则用于计算二进制形式的原权重向量和扰动后的权重向量之间的汉明距，而Nb则是最大汉明距



## 量化及编码

### <a class="reference-link" name="%E6%9D%83%E9%87%8D%E9%87%8F%E5%8C%96"></a>权重量化

我们逐层使用Nq-bits统一量化器对权重进行量化。对于第l层，从浮点形式的Wfp-l到定点形式(有符号整数)的Wl的量化过程可以描述为：

[![](https://p4.ssl.qhimg.com/t013ba0826782666041.png)](https://p4.ssl.qhimg.com/t013ba0826782666041.png)

其中d是权重张量的维度，∆wl是权重量化器的步长。由于∆wl是第l层所有权重共享的系数，我们只存储其定点部分，也就是

[![](https://p1.ssl.qhimg.com/t0101c4011759e42327.png)](https://p1.ssl.qhimg.com/t0101c4011759e42327.png)

### <a class="reference-link" name="%E6%9D%83%E9%87%8D%E7%BC%96%E7%A0%81"></a>权重编码

计算机通常将有符号整数以二进制的补码进行存储，这一点大家学过计算机组成原理的应该都清楚，这是为了在算术运算中的效率。给定一个权重元素w，其二进制的补码表示为：

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p0.ssl.qhimg.com/t013664e035534cc1cf.png)

其中b是w对应的二进制表示

[![](https://p4.ssl.qhimg.com/t011e48af319ae24d1a.png)](https://p4.ssl.qhimg.com/t011e48af319ae24d1a.png)

利用上式中g函数的转换关系，我们也可以从定点形式的权重反向得到其二进制表示



## 比特翻转攻击

这一步是攻击方案的关键之一，我们采用类似于FGSM的方式，FGSM大家应该都很熟悉，是生成对抗样本的经典方案，我们攻击方案的思路就是利用DNN的损失沿着其梯度上升方向翻转比特。我们以上式中的b为例，对b进行翻转攻击

我们首先计算b关于损失的梯度

[![](https://p1.ssl.qhimg.com/t0172dadb77012f0264.png)](https://p1.ssl.qhimg.com/t0172dadb77012f0264.png)

其中L是被b参数化的DNN的推理损失。

最直接的操作就是使用上式得到的梯度进行比特翻转，并得到扰动后的比特如下

[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)](https://p3.ssl.qhimg.com/t01f12f91804c379849.png)

其中

[![](https://p5.ssl.qhimg.com/t014cd87a6e9fd00dca.png)](https://p5.ssl.qhimg.com/t014cd87a6e9fd00dca.png)

然而，由于比特值是0，1组成的，像上式一样翻转比特会导致数据溢出。

实际上我们应该根据下面的真值表进行翻转

[![](https://p0.ssl.qhimg.com/t01f5c0b5039beb4c09.png)](https://p0.ssl.qhimg.com/t01f5c0b5039beb4c09.png)

上表中bi是原来的比特，bi^是扰动后的比特，m指示变换情况，L对bi求偏导的正负情况可以对应地用1或0表示

因此，我们需要重新设计比特翻转的流程：

[![](https://p4.ssl.qhimg.com/t0184be7f1f345ff0eb.png)](https://p4.ssl.qhimg.com/t0184be7f1f345ff0eb.png)

上式中的 ⊕是逐位异或的符号，m是掩码，用来指示某一位是否进行比特翻转的操作



## 渐进位搜索

我们知道整个深度学习网络有大量的参数，我们不可能在整个网络上对每个比特进行翻转，我们需要有一种更精确和有效的方式，这就是本小节会介绍的内容。我们使用渐进位搜索(progressive bit search)，其结合了梯度排序和渐进搜索，该方案会尝试在每个迭代中识别和翻转最脆弱的比特位，从而逐步降低模型的性能，直到达到预设的低精度或者达到预设的迭代次数。整个流程图如下

[![](https://p5.ssl.qhimg.com/t015e80b8c90fb511d6.png)](https://p5.ssl.qhimg.com/t015e80b8c90fb511d6.png)

对于每次迭代，搜索过程可以分为两个连续的步骤：

1.层内搜索：在选定的层内，记录并比较被选择的比特翻转后模型得到的推理损失

2.跨层搜索：对网络的每一层进行独立的层内搜索，评估层内搜索时记录的损失变化量，从而识别出跨不同层的最脆弱的比特位。

### <a class="reference-link" name="%E5%B1%82%E5%86%85%E6%90%9C%E7%B4%A2"></a>层内搜索

在第k次迭代中，在第l层内通过梯度排序进行层内搜索

给定向量化的输入x和目标t，推理、反向传播的过程会被依序执行以计算对于推理损失的梯度。然后，我们通过梯度∂L/∂b的绝对值对比特的脆弱性进行降序排序，并选出梯度前nb个的比特，这个过程可以写作：

[![](https://p5.ssl.qhimg.com/t0158e4b87e3e3278da.png)](https://p5.ssl.qhimg.com/t0158e4b87e3e3278da.png)

其中，`{`Topnb`}`函数会返回一个指针，其指向选中的nb个比特在内存中的位置

然后我们对其进行翻转

[![](https://p3.ssl.qhimg.com/t01ddf95170f4a4cd5d.png)](https://p3.ssl.qhimg.com/t01ddf95170f4a4cd5d.png)

接着我们要记录翻转后模型推理损失的变化情况，其计算如下

[![](https://p5.ssl.qhimg.com/t01e9873edbffdbeabf.png)](https://p5.ssl.qhimg.com/t01e9873edbffdbeabf.png)

其中[![](https://p3.ssl.qhimg.com/t01a6f43b3993248393.png)](https://p3.ssl.qhimg.com/t01a6f43b3993248393.png)

和[![](https://p5.ssl.qhimg.com/t0133085d55fee92cb4.png)](https://p5.ssl.qhimg.com/t0133085d55fee92cb4.png)

之间的唯一区别就是上面翻转的比特

### <a class="reference-link" name="%E8%B7%A8%E5%B1%82%E6%90%9C%E7%B4%A2"></a>跨层搜索

跨层搜索是在整个网络内进行评估。

在第k次迭代中，跨层搜索首先对每一层独立进行层内搜索，并生成损失集合`{`Lk1, Lk2，···，LkL`}`，然后我们可以识别出损失最大的层j，并在选定的j层中对选中的比特位进行比特翻转，即表示如下：

[![](https://p5.ssl.qhimg.com/t01d3b1cf26a92bfb5c.png)](https://p5.ssl.qhimg.com/t01d3b1cf26a92bfb5c.png)

然后进行第k+1次迭代。

在ResNet-18对ImageNet数据集上，攻击效果如下所示

[![](https://p4.ssl.qhimg.com/t018fcad61facdae475.png)](https://p4.ssl.qhimg.com/t018fcad61facdae475.png)

图中的Nflip是攻击将top-1精度降低到11%以下所需的位翻转次数。

在上面分别绘制了Top-1验证精度、Top-5验证精度、Sample loss和validation loss。基于攻击样本量的攻击性能可以发现:S(128) &gt; S(32) &gt; S(256) &gt; S(64) &gt; S(16)。从结果可以看出，即使输入样本大小很小，攻击仍然可以在非常小的比特翻转情况下生效。



## 实战

### <a class="reference-link" name="%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"></a>基础函数

形式转换函数、权重转换函数

[![](https://p0.ssl.qhimg.com/t019751b1e71647bc46.png)](https://p0.ssl.qhimg.com/t019751b1e71647bc46.png)

计算汉明距的函数

[![](https://p4.ssl.qhimg.com/t0147b44bf59280d77d.png)](https://p4.ssl.qhimg.com/t0147b44bf59280d77d.png)

### <a class="reference-link" name="%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%96"></a>模型量化

对模型进行量化的函数，这里省略了非关键的部分，下面是对卷积进行量化的函数，对线性进行量化也是同理

[![](https://p0.ssl.qhimg.com/t01329f7097b755296d.png)](https://p0.ssl.qhimg.com/t01329f7097b755296d.png)

### <a class="reference-link" name="%E7%BF%BB%E8%BD%AC%E6%9D%83%E9%87%8D"></a>翻转权重

[![](https://p1.ssl.qhimg.com/t01a6f83acfff1a0595.png)](https://p1.ssl.qhimg.com/t01a6f83acfff1a0595.png)

### <a class="reference-link" name="%E6%B8%90%E8%BF%9B%E4%BD%8D%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"></a>渐进位搜索算法

[![](https://p4.ssl.qhimg.com/t013559e699c058c6fb.png)](https://p4.ssl.qhimg.com/t013559e699c058c6fb.png)

实验结果如下

[![](https://p2.ssl.qhimg.com/t016bbb85fb44bd9e3f.png)](https://p2.ssl.qhimg.com/t016bbb85fb44bd9e3f.png)

可以看到，在翻转2个比特后，已经将损失提升了20%左右。

### <a class="reference-link" name="%E6%89%A9%E5%B1%95"></a>扩展

本文介绍的方案是通过比特翻转攻击全面降低了模型的性能，或者说实现了非定向攻击，实际上，该技术也可以用于实现定向攻击，即与后门攻击相结合，如下所示

[![](https://p0.ssl.qhimg.com/t0175c18094cafc82fe.jpg)](https://p0.ssl.qhimg.com/t0175c18094cafc82fe.jpg)

当利用该技术发动后门攻击时，模型会将所有的输入样本都预测为指定的类别，关于这种攻击方案，有兴趣的师傅们可以从参考文献[2]中获取更详细的资料。



## 参考

1.Rakin A S, He Z, Fan D. Bit-flip attack: Crushing neural network with progressive bit search[C]//Proceedings of the IEEE/CVF International Conference on Computer Vision. 2019: 1211-1220.

2.Rakin A S, He Z, Li J, et al. T-bfa: Targeted bit-flip adversarial weight attack[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2021.

3.Mutlu O, Kim J S. Rowhammer: A retrospective[J]. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 2019, 39(8): 1555-1571.

4.Kim Y, Daly R, Kim J, et al. Flipping bits in memory without accessing them: An experimental study of DRAM disturbance errors[J]. ACM SIGARCH Computer Architecture News, 2014, 42(3): 361-372.
